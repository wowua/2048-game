{"version":3,"sources":["types.ts","core/matrix.ts","core/constants.ts","core/creator.ts","core/engine.ts","core/updater.ts","services/score.ts","HOC/withDynamicCounter.tsx","components/Layout/style.tsx","components/Layout/index.tsx","components/Field/helpers.ts","components/Field/styles.tsx","components/Field/index.tsx","components/ControlPanel/style.tsx","components/Button/index.tsx","components/ControlPanel/index.tsx","components/Scoreboard/style.tsx","components/Scoreboard/index.tsx","components/SplashScreen/styles.tsx","components/SplashScreen/index.tsx","App.tsx","index.tsx"],"names":["Direction","CellType","generateCheckSumByCoords","x","y","traverseMatrix","matrixToTraverse","cb","matrix","cloneDeep","breakLoop","rotateMatrix","traversedMatrix","reverse","reverseRows","transpose","create","cell","id","uniqueId","value","state","getRandomCoord","Math","floor","random","createInitialCells","firstCell","IDLE","secondCell","buildMatrixWithCells","cells","matrixSize","matrixToFill","Array","from","forEach","populateFieldWithNewCells","occupiedCoords","Set","add","collectOccupiedCellsCheckSums","size","takenCoords","prevSetSize","getAvailableCoords","BORN","cellsValuesAreSame","prevCell","currentCell","cellIsInIdleState","cellIsInMovingState","MOVING","substituteEmptyCell","originalMatrix","emptyCell","substituteFilledCell","cellToReplace","DYING","INCREASE","updateCellsCoords","cellsToUpdate","moveCellsUpInMatrix","matrixToTransform","currentRowY","prevRowY","cellAbove","moveCellsToDirection","cellsToMove","direction","rotatedMatrix","LEFT","DOWN","RIGHT","rotateMatrixToDirection","rotatedBackMatrix","rotateMatrixFromDirection","flat","filter","checkAvailableMoves","hasAvailableMove","neighbourCells","values","cellValue","has","checkCellsValuesAreSame","currentX","currentY","aboveCell","belowCell","nextCell","aboveCellY","belowCellY","nextCellX","prevCellX","getNeighbourCells","removeAndIncreaseCells","gainScores","counter","num","scoresGatherer","isGoingToDie","map","needsToIncrease","scoreService","number","localStorage","setItem","toString","score","getItem","Number","Addition","styled","div","animated","Container","Main","main","Content","Layout","children","calculateBackgroundColor","step","min","log2","calculateSaturation","calculateLightness","calcPlaygroundSize","cellSize","marginSize","SplashContainer","Background","Playground","BackgroundCell","Cell","props","Field","_","i","key","Controlls","Board","Button","button","ControlPanel","onRunNewGame","onClick","Score","Counter","Title","Scoreboard","title","WrappedComponent","h2","SplashScreen","onRetry","initCells","ScoresWithDynamicCounter","gainedScores","useState","animationStarted","setAnimationStarted","useEffect","timemout","clearTimeout","setTimeout","bestScore","mappedKeysToDirections","ArrowUp","UP","ArrowRight","ArrowDown","ArrowLeft","App","setCells","totalScores","setTotalScores","setGainedScores","splashIsShown","setSplashIsShown","runNewGame","updateFieldByDirection","currentCellsSet","movedCells","cleanedAndIncreasedCells","gainedScoresAfterMove","resultCells","totalScoreAfterMove","reduce","acc","occupiedCells","availableCells","length","isEmptyCellsExist","handleKeyPress","event","Object","keys","includes","code","document","addEventListener","removeEventListener","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.f7e04e93.chunk.js","sourcesContent":["export enum Direction {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport enum CellType {\n  IDLE = 'IDLE',\n  BORN = 'BORN',\n  MOVING = 'MOVING',\n  DYING = 'DYING',\n  INCREASE = 'INCREASE'\n}\n\nexport type GameCell = {\n  id?: string;\n  x: number;\n  y: number;\n  value: number;\n  state: CellType;\n}\n\nexport type CellCoords = {\n  x: number;\n  y: number;\n}\n\nexport type MatrixCell = GameCell | number;\n\nexport type Matrix = MatrixCell[][];\n\nexport type MoveCellsFunction =\n    (matrixToTransform: Matrix, x: number, y: number) => Matrix;\n","import { cloneDeep } from 'lodash';\nimport {\n  Direction, GameCell,\n} from '../types';\nimport { MATRIX_SIZE } from './constants';\n\nexport const generateCheckSumByCoords = (x: number, y: number): number => x * MATRIX_SIZE + y;\n\nexport const traverseMatrix = <T>(\n  matrixToTraverse: T[][],\n  cb: (\n    matrix: T[][], x: number, y: number, breakLoopFn?: () => void\n  ) => T[][],\n): T[][] => {\n  let matrix = cloneDeep<T[][]>(matrixToTraverse);\n  let breakLoop = false;\n\n  for (let y = 0; y < MATRIX_SIZE; y++) {\n    for (let x = 0; x < MATRIX_SIZE; x++) {\n      matrix = cb(matrix, x, y, () => {\n        breakLoop = true;\n      }) as T[][];\n      if (breakLoop) break;\n    }\n    if (breakLoop) break;\n  }\n\n  return matrix;\n};\n\n\nexport const reverseRows = <T>(matrix: T[][]): T[][] => traverseMatrix<T>(\n  matrix,\n  (traversedMatrix, x, y) => {\n    if (x <= 0) {\n      traversedMatrix[y] = traversedMatrix[y].reverse();\n    }\n    return traversedMatrix;\n  },\n);\n\nexport const transpose = <T>(matrix: T[][]): T[][] => traverseMatrix<T>(\n  matrix,\n  (traversedMatrix, x, y) => {\n    traversedMatrix[y][x] = matrix[x][y];\n    return traversedMatrix;\n  },\n);\n\nexport const rotateMatrix = <T>(matrix: T[][]): T[][] => {\n  const transposedMatrix: T[][] = transpose(matrix);\n  return reverseRows(transposedMatrix);\n};\n\nexport const rotateMatrixFromDirection = <T>(matrix: T[][], direction: Direction): T[][] => {\n  switch (direction) {\n    case Direction.LEFT:\n      return rotateMatrix(rotateMatrix(rotateMatrix(matrix)));\n    case Direction.DOWN:\n      return rotateMatrix(rotateMatrix(matrix));\n    case Direction.RIGHT:\n      return rotateMatrix(matrix);\n    default:\n      return matrix;\n  }\n};\n\nexport const rotateMatrixToDirection = <T>(matrix: T[][], direction: Direction): T[][] => {\n  switch (direction) {\n    case Direction.LEFT:\n      return rotateMatrix(matrix);\n    case Direction.DOWN:\n      return rotateMatrix(rotateMatrix(matrix));\n    case Direction.RIGHT:\n      return rotateMatrix(rotateMatrix(rotateMatrix(matrix)));\n    default:\n      return matrix;\n  }\n};\n","export const MATRIX_SIZE = 4;\n","import { cloneDeep, uniqueId } from 'lodash';\nimport {\n  CellType, GameCell, Matrix, MatrixCell,\n} from '../types';\nimport { generateCheckSumByCoords } from './matrix';\nimport { MATRIX_SIZE } from './constants';\n\nexport const create = (cell: GameCell): GameCell => ({\n  x: cell.x,\n  y: cell.y,\n  id: cell.id ? cell.id : uniqueId(),\n  value: cell.value,\n  state: cell.state,\n});\n\nexport const getRandomCoord = () : number => Math.floor(Math.random() * (MATRIX_SIZE - 0.1));\n\nexport const createInitialCells = () : GameCell[] => {\n  const firstCell: GameCell = create({\n    x: getRandomCoord(), y: getRandomCoord(), value: 2, state: CellType.IDLE,\n  });\n  const secondCell: GameCell = create(\n    {\n      x: getRandomCoord(), y: getRandomCoord(), value: 2, state: CellType.IDLE,\n    },\n  );\n\n  if (firstCell.x === secondCell.x && firstCell.y === secondCell.y) {\n    firstCell.x = firstCell.x === 0 ? 1 : firstCell.x - 1;\n  }\n\n  return [firstCell, secondCell];\n};\n\nexport const createEmptyMatrix = (matrixSize: number): MatrixCell[][] => Array.from(\n  new Array(matrixSize), () => Array.from(new Array(matrixSize), () => 0),\n);\n\nexport const buildMatrixWithCells = (cells: GameCell[]): Matrix => {\n  const matrixToFill = createEmptyMatrix(MATRIX_SIZE);\n\n  cells.forEach((cell: GameCell) => {\n    matrixToFill[cell.y][cell.x] = cell;\n  });\n\n  return matrixToFill;\n};\n\nexport const getAvailableCoords = (occupiedCoords: Set<number>): [number, number] => {\n  const takenCoords = cloneDeep<Set<number>>(occupiedCoords);\n  const prevSetSize = takenCoords.size;\n  let x = 0;\n  let y = 0;\n\n  do {\n    x = getRandomCoord();\n    y = getRandomCoord();\n\n    takenCoords.add(generateCheckSumByCoords(x, y));\n  } while (prevSetSize === takenCoords.size);\n\n  return [x, y];\n};\n\nexport const collectOccupiedCellsCheckSums = (cells: GameCell[]): Set<number> => {\n  const occupiedCoords = new Set<number>();\n\n  cells.forEach((cell) => {\n    occupiedCoords.add(generateCheckSumByCoords(cell.x, cell.y));\n  });\n\n  return occupiedCoords;\n};\n\nexport const populateFieldWithNewCells = (cells: GameCell[]): GameCell[] => {\n  const occupiedCoords = collectOccupiedCellsCheckSums(cells);\n  const allCellsAreFilled = occupiedCoords.size === MATRIX_SIZE ** 2;\n\n  if (allCellsAreFilled) return cells;\n\n  const [x, y] = getAvailableCoords(occupiedCoords);\n  occupiedCoords.add(generateCheckSumByCoords(x, y)); // ?\n\n  return [...cells, create({\n    x, y, value: 2, state: CellType.BORN,\n  })];\n};\n","import { cloneDeep } from 'lodash';\nimport {\n  CellCoords, CellType, Direction, GameCell, Matrix, MatrixCell, MoveCellsFunction,\n} from '../types';\n\nimport {\n  generateCheckSumByCoords,\n  rotateMatrixToDirection,\n  rotateMatrixFromDirection,\n  traverseMatrix,\n} from './matrix';\n\nimport { buildMatrixWithCells } from './creator';\nimport { MATRIX_SIZE } from './constants';\n\nexport const cellIsEmpty = (cell: MatrixCell): boolean => cell === 0;\n\nexport const cellsValuesAreSame = (\n  prevCell: MatrixCell,\n  currentCell: MatrixCell,\n): boolean => (\n  (prevCell as GameCell).value === (currentCell as GameCell).value\n);\n\nexport const matrixAreSame = (\n  prevCellsSet: GameCell[],\n  currentCellsSet: GameCell[],\n) : boolean => {\n  const prevCellsSum = prevCellsSet.reduce((\n    acc, cell,\n  ) => acc + generateCheckSumByCoords(cell.x, cell.y), 0);\n\n  const currentCellsSum = currentCellsSet.reduce((\n    acc, cell,\n  ) => acc + generateCheckSumByCoords(cell.x, cell.y), 0);\n\n  return prevCellsSum === currentCellsSum;\n};\n\nexport const cellIsInIdleState = (\n  cell: MatrixCell,\n): boolean => (cell as GameCell).state === CellType.IDLE\n  || (cell as GameCell).state === CellType.BORN;\n\nexport const cellIsInMovingState = (\n  cell: MatrixCell,\n): boolean => (cell as GameCell).state === CellType.MOVING;\n\nexport const substituteEmptyCell = (\n  originalMatrix: Matrix,\n  currentCell: CellCoords,\n  emptyCell: CellCoords,\n): Matrix => {\n  const matrix = cloneDeep(originalMatrix);\n\n  matrix[emptyCell.y][emptyCell.x] = matrix[currentCell.y][currentCell.x];\n  (matrix[currentCell.y][currentCell.x] as GameCell).state = CellType.MOVING;\n  (matrix[currentCell.y][currentCell.x] as 0) = 0;\n\n  return matrix;\n};\n\nexport const substituteFilledCell = (\n  originalMatrix: Matrix,\n  currentCell: CellCoords,\n  cellToReplace: CellCoords,\n): Matrix => {\n  const matrix = cloneDeep(originalMatrix);\n\n  (matrix[cellToReplace.y][cellToReplace.x] as GameCell).state = CellType.DYING;\n  (matrix[currentCell.y][currentCell.x] as GameCell).state = CellType.INCREASE;\n\n  matrix[cellToReplace.y][cellToReplace.x] = matrix[currentCell.y][currentCell.x];\n  (matrix[currentCell.y][currentCell.x] as number) = 0;\n\n  return matrix;\n};\n\nexport const updateCellsCoords: MoveCellsFunction = (\n  cellsToUpdate, x, y,\n) => {\n  if (cellsToUpdate[y][x] === 0) return cellsToUpdate;\n\n  (cellsToUpdate[y][x] as GameCell).y = y;\n  (cellsToUpdate[y][x] as GameCell).x = x;\n\n  return cellsToUpdate;\n};\n\nexport const moveCellsUpInMatrix: MoveCellsFunction = (\n  matrixToTransform, x, y,\n) => {\n  if (matrixToTransform[y][x] === 0) return matrixToTransform;\n\n  let currentRowY = y;\n  let prevRowY = y - 1;\n\n  while (prevRowY >= 0) {\n    const currentCell = matrixToTransform[currentRowY][x];\n    const cellAbove = matrixToTransform[prevRowY][x];\n\n    if (cellIsEmpty(cellAbove)) {\n      matrixToTransform = substituteEmptyCell(\n        matrixToTransform, { x, y: currentRowY }, { x, y: prevRowY },\n      );\n    }\n\n    if (\n      cellsValuesAreSame(cellAbove, currentCell)\n      && (cellIsInIdleState(cellAbove) || cellIsInMovingState(cellAbove))\n    ) {\n      matrixToTransform = substituteFilledCell(\n        matrixToTransform, { x, y: currentRowY }, { x, y: prevRowY },\n      );\n    }\n\n    currentRowY = prevRowY;\n    prevRowY--;\n  }\n\n  return matrixToTransform;\n};\n\nexport const moveCellsToDirection = (\n  cellsToMove: GameCell[], direction: Direction,\n): GameCell[] => {\n  const cells: GameCell[] = cloneDeep<GameCell[]>(cellsToMove);\n  const matrixWithCells = buildMatrixWithCells(cells);\n\n  const rotatedMatrix = rotateMatrixToDirection<MatrixCell>(matrixWithCells, direction);\n  const transformedMatrix = traverseMatrix<MatrixCell>(rotatedMatrix, moveCellsUpInMatrix);\n  const rotatedBackMatrix = rotateMatrixFromDirection<MatrixCell>(transformedMatrix, direction);\n  const finalMatrix = traverseMatrix<MatrixCell>(rotatedBackMatrix, updateCellsCoords);\n\n  return finalMatrix.flat(2).filter((cell: MatrixCell) => cell !== 0);\n};\n\nexport const isEmptyCellsExist = (occupiedCells: GameCell[]) : boolean => {\n  const availableCells = MATRIX_SIZE ** 2;\n  return occupiedCells.length < availableCells;\n};\n\nexport const getNeighbourCells = (\n  matrix: Matrix, currentX: number, currentY: number,\n): GameCell[] => {\n  let aboveCell: MatrixCell = 0;\n  let belowCell: MatrixCell = 0;\n  let nextCell: MatrixCell = 0;\n  let prevCell: MatrixCell = 0;\n\n  const aboveCellY = currentY - 1;\n  const belowCellY = currentY + 1;\n  const nextCellX = currentX + 1;\n  const prevCellX = currentX - 1;\n\n  if (aboveCellY >= 0) {\n    aboveCell = matrix[aboveCellY][currentX];\n  }\n\n  if (belowCellY < MATRIX_SIZE) {\n    belowCell = matrix[belowCellY][currentX];\n  }\n\n  if (prevCellX >= 0) {\n    prevCell = matrix[currentY][prevCellX];\n  }\n\n  if (nextCellX < MATRIX_SIZE) {\n    nextCell = matrix[currentY][nextCellX];\n  }\n\n  return [nextCell, belowCell, prevCell, aboveCell].filter(\n    (cell) => cell !== 0,\n  ) as GameCell[];\n};\n\nexport const checkCellsValuesAreSame = (\n  currentCell: GameCell, neighbourCells: GameCell[],\n): boolean => {\n  const values = new Set<number>();\n\n  neighbourCells.forEach((cell) => {\n    const cellValue: number = cell.value;\n    values.add(cellValue);\n  });\n\n  return values.has(currentCell.value);\n};\n\nexport const checkAvailableMoves = (cells: GameCell[]): boolean => {\n  const matrix: Matrix = buildMatrixWithCells(cells);\n  let hasAvailableMove = false;\n\n  traverseMatrix(matrix,\n    (traversedMatrix, x, y, breakLoop) => {\n      const currentCell = traversedMatrix[y][x] as MatrixCell;\n      if (currentCell === 0) return traversedMatrix;\n      const neighbourCells = getNeighbourCells(traversedMatrix, x, y);\n      const valuesAreSame = checkCellsValuesAreSame(currentCell as GameCell, neighbourCells);\n\n      if (valuesAreSame) {\n        hasAvailableMove = true;\n        if (typeof breakLoop === 'function') breakLoop();\n      }\n      return traversedMatrix;\n    });\n\n  return hasAvailableMove;\n};\n","import { CellType, GameCell } from '../types';\n\nexport const isGoingToDie = (cell: GameCell) => cell.state === CellType.DYING;\nexport const needsToIncrease = (cell: GameCell) => cell.state === CellType.INCREASE;\n\nexport const scoresGatherer = (): (num: number) => number => {\n  let counter = 0;\n  return function increaser(num = 0): number {\n    counter += num;\n    return counter;\n  };\n};\n\nexport const removeAndIncreaseCells = (\n  cells: GameCell[],\n): [ GameCell[], number ] => {\n  const gainScores = scoresGatherer();\n\n  const updatedCells = cells\n    .filter((cell) => !isGoingToDie(cell))\n    .map((cell) => {\n      if (needsToIncrease(cell)) {\n        cell.value *= 2;\n        gainScores(cell.value);\n      }\n\n      cell.state = CellType.IDLE;\n\n      return cell;\n    });\n\n  return [updatedCells, gainScores(0)];\n};\n\n","export const scoreService = {\n  save(number: number): void {\n    localStorage.setItem('score', number.toString());\n  },\n  get(): number {\n    const score = localStorage.getItem('score');\n    if (!score) return 0;\n\n    return Number(score);\n  },\n};\n","import React, {\n  useEffect, useState, FC, ReactElement,\n} from 'react';\nimport styled from 'styled-components';\n\ninterface ScoresProps {\n  animated: boolean;\n}\n\nexport const Addition = styled.div<ScoresProps>`\n  color: #95ac95;\n  margin-right: 12px;\n  font-size: 20px;\n  font-weight: bold;\n  \n  ${({ animated }) => animated && `\n    animation: fadeUp .4s; \n    animation-delay: .3s;\n    animation-fill-mode: forwards;\n  `} \n  \n  @keyframes fadeUp {\n    from { transform: translateY(0); opacity: 1 }\n    to { transform: translateY(-50px); opacity: 0 }\n  }\n`;\n\nexport const Container = styled.div`\n  display: flex;\n  font-weight: 500;\n  align-items: center;\n  font-size: 16px;\n`;\n\ntype WrappedPropTypes = {\n  score: number,\n  title: string\n}\n\ntype HOCPropTypes = {\n  gainedScores: number,\n  title: string,\n  score: number\n}\n\nexport const withDynamicCounter = (WrappedComponent: FC<WrappedPropTypes>) => function (\n  { gainedScores, title, score }: HOCPropTypes,\n): ReactElement {\n  const [animationStarted, setAnimationStarted] = useState<boolean>(false);\n\n  useEffect(() => {\n    setAnimationStarted(false);\n\n    let timemout = 0;\n    if (timemout > 0) clearTimeout(timemout);\n\n    timemout = setTimeout(() => {\n      setAnimationStarted(true);\n    }, 10);\n\n    return () => {\n      clearTimeout(timemout);\n    };\n  }, [gainedScores]);\n\n  return (\n    <Container>\n      {\n        gainedScores > 0 && (\n          <Addition animated={animationStarted}>\n            {`+ ${gainedScores}`}\n          </Addition>\n        )\n      }\n      <WrappedComponent score={score} title={title} />\n    </Container>\n  );\n};\n","import styled from 'styled-components';\n\nexport const Main = styled.main`\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  width: 100%;\n`;\n\nexport const Content = styled.div`\n  min-height: 600px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`;\n","import React, { FC, ReactNode } from 'react';\nimport { Main, Content } from './style';\n\ntype PropTypes = {\n  children: ReactNode;\n}\n\nconst Layout: FC<PropTypes> = ({ children }: PropTypes) => (\n  <Main>\n    <Content>{children}</Content>\n  </Main>\n);\n\nexport default Layout;\n","export const calculateSaturation = (step: number): number => Math.floor(100 / 16 * step);\n\nexport const calculateLightness = (step: number): number => 100 - Math.floor(50 / 16 * step);\n\nexport const calculateBackgroundColor = (value : number) : string => {\n  if (value === 0) {\n    return 'transparent';\n  }\n  // from 0 to 16\n  const step = Math.min(16, Math.log2(value));\n  return `hsl(0, ${calculateSaturation(step)}%, ${calculateLightness(step)}%);`;\n};\n\nexport const calcFontSize = (value: number) : number => {\n  let result;\n  if (value < 100) {\n    result = 66;\n  } else if (value < 1000) {\n    result = 47;\n  } else if (value < 10000) {\n    result = 40;\n  } else {\n    result = 30;\n  }\n\n  return result;\n};\n","import styled from 'styled-components';\nimport {\n  calcFontSize, calculateBackgroundColor,\n} from './helpers';\nimport { CellType } from '../../types';\nimport { MATRIX_SIZE } from '../../core/constants';\n\ninterface CellProps {\n  x: number;\n  y: number;\n  value: number;\n  state: CellType;\n}\n\nexport const calcPlaygroundSize = (\n  cellSize: number, marginSize: number,\n): number => cellSize * MATRIX_SIZE + marginSize * 2 * MATRIX_SIZE + 10;\n\nexport const Container = styled.div`\n  height:  ${calcPlaygroundSize(100, 5)}px;\n  width: ${calcPlaygroundSize(100, 5)}px;\n  position: relative;\n`;\n\nexport const SplashContainer = styled.div`\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n`;\n\nexport const Background = styled.div`\n  align-content: space-between;\n  background-color: #bbada0;\n  border-radius: 10px;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: space-between;\n  padding: 5px;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n`;\n\nexport const Playground = styled(Background)`\n  background-color: transparent;\n`;\n\nexport const BackgroundCell = styled.div`\n  margin: 5px;\n  background-color: rgba(238, 228, 218, 0.35);\n  height: 100px;\n  width: 100px;\n  border-radius: 5px;\n`;\n\nexport const calcTranslate = (x: number, y: number): string => `\n  translate(${x * 110}px, ${y * 110}px)\n`;\n\nexport const Cell = styled(BackgroundCell)<CellProps>`\n  // transform: ${(props) => calcTranslate(props.x, props.y)};\n  left: ${(props) => props.x * 110 + 5}px;\n  top: ${(props) => props.y * 110 + 5}px;\n  text-align: center;\n  line-height: 100px;\n  background-color: ${({ value }) => calculateBackgroundColor(value)};\n  position: absolute;\n  transition: .1s;\n  color: #6a4e4e;\n  font-weight: 900;\n  font-size: ${(props) => `${calcFontSize(props.value)}px`};\n  will-change: transform;\n    \n  ${({ state }) => state === CellType.BORN && `\n    animation: zoom .1s;\n  `}  \n  \n  @keyframes zoom {\n    from { transform: scale(.5); }\n    to { transform: scale(1); }\n  }\n`;\n","import React, { FC } from 'react';\nimport { GameCell } from '../../types';\n\nimport {\n  Container, Background, BackgroundCell, Playground, Cell, SplashContainer,\n} from './styles';\nimport { MATRIX_SIZE } from '../../core/constants';\n\ntype PropTypes = {\n  cells: GameCell[];\n}\n\nconst Field : FC<PropTypes> = ({ cells, children }) => (\n  <Container>\n    <Background>\n      {\n        Array\n          .from(new Array(MATRIX_SIZE ** 2), (_, i) => i)\n          .map((i) => <BackgroundCell key={i} />)\n      }\n    </Background>\n\n    <Playground>\n      {cells.map(({\n        x, y, value, id, state,\n      }: GameCell) => (\n        <Cell key={id} x={x} y={y} value={value} state={state}>\n          {value}\n        </Cell>\n      ))}\n    </Playground>\n    <SplashContainer>\n      {children}\n    </SplashContainer>\n  </Container>\n);\n\nexport default Field;\n","import styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: flex;\n  padding: 20px 0;\n  width: 100%;\n  align-items: center;\n`;\n\nexport const Controlls = styled.div``;\n\nexport const Board = styled.div`\n  margin-left: auto;\n  display: flex;\n  align-items: center;\n  \n  & > * {\n    margin-right: 12px;\n    \n    &:last-child {\n      margin-right: 0px;\n    }\n  }\n`;\n","import styled from 'styled-components';\n\nconst Button = styled.button`\n  background: #8f7a66;\n  border-radius: 5px;\n  border: none;\n  color: #fff;\n  cursor: pointer;\n  font-size: 18px;\n  font-weight: bold;\n  outline: none;\n  padding: 12px 20px;\n  text-transform: capitalize;\n  align-items: center;\n  \n  &:hover {\n    background: brown;\n  }\n`;\n\nexport default Button;\n","import React, { FC, ReactNode } from 'react';\nimport { Container, Controlls, Board } from './style';\nimport Button from '../Button';\n\ntype PropTypes = {\n  children: ReactNode,\n  onRunNewGame: () => void;\n}\n\nconst ControlPanel: FC<PropTypes> = ({ children, onRunNewGame }: PropTypes) => (\n  <Container>\n    <Controlls>\n      <Button onClick={onRunNewGame}>New Game</Button>\n    </Controlls>\n    <Board>\n      {children}\n    </Board>\n  </Container>\n);\n\nexport default ControlPanel;\n","import styled from 'styled-components';\n\nexport const Score = styled.div`\n  padding: 10px 25px;\n  background-color: #eee;\n  border-radius: 5px;\n  display: flex;\n  flex-direction: column;\n  background: #bbada0;\n  align-items: center;\n`;\n\nexport const Counter = styled.div`\n  font-size: 25px;\n  font-weight: bold;\n  color: #fff;\n`;\n\nexport const Title = styled.div`\n  color: #eee4da;\n  font-size: 13px;\n  text-transform: uppercase;\n`;\n","import React, { FC } from 'react';\nimport {\n  Score, Title, Counter,\n} from './style';\n\ntype PropTypes = {\n  score: number,\n  title: string\n}\n\nconst Scoreboard: FC<PropTypes> = ({ score, title }: PropTypes) => (\n  <Score>\n    <Title>{title}</Title>\n    <Counter>{score}</Counter>\n  </Score>\n);\n\nexport default Scoreboard;\n","import styled from 'styled-components';\n\nexport const Container = styled.div`\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: rgba(238, 228, 218, 0.73);\n  flex-direction: column;\n`;\n\nexport const Title = styled.h2`\n  color: #776e65;\n  font-size: 60px;\n  margin-top: 0;\n`;\n","import React, { FC } from 'react';\nimport { Container, Title } from './styles';\nimport Button from '../Button';\n\ntype PropTypes = {\n  title: string,\n  onRetry: () => void;\n};\n\nconst SplashScreen: FC<PropTypes> = ({ title, onRetry }: PropTypes) => (\n  <Container>\n    <Title>{title}</Title>\n    <Button onClick={onRetry}>Try Again</Button>\n  </Container>\n);\n\nexport default SplashScreen;\n","import React, { FC, useState, useEffect } from 'react';\nimport { GameCell, Direction } from './types';\n\nimport { createInitialCells, populateFieldWithNewCells } from './core/creator';\nimport {\n  checkAvailableMoves, isEmptyCellsExist, moveCellsToDirection, matrixAreSame,\n} from './core/engine';\nimport { removeAndIncreaseCells } from './core/updater';\n\nimport { scoreService } from './services/score';\nimport { withDynamicCounter } from './HOC/withDynamicCounter';\n\nimport Layout from './components/Layout';\nimport Field from './components/Field';\nimport ControlPanel from './components/ControlPanel';\nimport Scoreboard from './components/Scoreboard';\nimport SplashScreen from './components/SplashScreen';\n\nconst initCells : GameCell[] = createInitialCells();\n\nconst ScoresWithDynamicCounter = withDynamicCounter(Scoreboard);\n\nlet bestScore = scoreService.get();\n\nconst mappedKeysToDirections: {\n  [key: string]: Direction\n} = {\n  ArrowUp: Direction.UP,\n  ArrowRight: Direction.RIGHT,\n  ArrowDown: Direction.DOWN,\n  ArrowLeft: Direction.LEFT,\n};\n\nconst App: FC = () => {\n  const [cells, setCells] = useState<GameCell[]>(initCells);\n  const [totalScores, setTotalScores] = useState<number>(0);\n  const [gainedScores, setGainedScores] = useState<number>(0);\n  const [splashIsShown, setSplashIsShown] = useState<boolean>(false);\n\n  const runNewGame = (): void => {\n    bestScore = scoreService.get();\n    setCells(createInitialCells());\n    setTotalScores(0);\n    setSplashIsShown(false);\n  };\n\n  const updateFieldByDirection = (direction: Direction) => {\n    const movedCells = moveCellsToDirection(cells, direction);\n    const [cleanedAndIncreasedCells, gainedScoresAfterMove] = removeAndIncreaseCells(movedCells);\n    let resultCells: GameCell[] = cleanedAndIncreasedCells;\n    const totalScoreAfterMove = totalScores + gainedScoresAfterMove;\n\n    if (!matrixAreSame(cells, cleanedAndIncreasedCells)) {\n      resultCells = populateFieldWithNewCells(cleanedAndIncreasedCells);\n\n      const fieldHasAvailableCells = isEmptyCellsExist(resultCells);\n\n      if (!fieldHasAvailableCells) {\n        const hasAvailableMove = checkAvailableMoves(resultCells);\n        if (!hasAvailableMove) setSplashIsShown(true);\n      }\n    }\n\n    setCells(resultCells);\n    setGainedScores(gainedScoresAfterMove);\n    setTotalScores(totalScoreAfterMove);\n\n    if (totalScoreAfterMove > bestScore) {\n      scoreService.save(totalScoreAfterMove);\n    }\n  };\n\n  const handleKeyPress = (event: KeyboardEvent): void => {\n    if (Object.keys(mappedKeysToDirections).includes(event.code)) {\n      updateFieldByDirection(mappedKeysToDirections[event.code]);\n    }\n  };\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyPress);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyPress);\n    };\n  });\n\n  return (\n    <Layout>\n      <ControlPanel onRunNewGame={runNewGame}>\n        <ScoresWithDynamicCounter gainedScores={gainedScores} score={totalScores} title=\"score\" />\n        <Scoreboard score={bestScore} title=\"Best\" />\n      </ControlPanel>\n      <Field cells={cells}>\n        {\n          splashIsShown\n          && <SplashScreen title=\"Game Over\" onRetry={runNewGame} />\n        }\n      </Field>\n    </Layout>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.css';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}